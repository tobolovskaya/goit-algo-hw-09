# -*- coding: utf-8 -*-
"""ДЗ9_Тоболовська Євгенія.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bcg8KITRnO9Lx551xiBGnycwoxPtVIw7

Функція жадібного алгоритму
"""

def find_coins_greedy(amount):
    # Перелік монет із їх номіналами
    coins = [50, 25, 10, 5, 2, 1]
    # Словник для зберігання кількості монет кожного номіналу
    result = {}

    for coin in coins:
        # Знаходимо кількість монет поточного номіналу, які потрібно видачі
        coin_count = amount // coin
        if coin_count > 0:
            result[coin] = coin_count
            amount -= coin * coin_count

    return result

# Приклад використання функції
find_coins_greedy(113)  # Повинно повернути {50: 2, 10: 1, 2: 1, 1: 1}

"""Функція динамічного програмування"""

def find_min_coins(amount, coins=[50, 25, 10, 5, 2, 1]):
    # Ініціалізація масиву для зберігання мінімальної кількості монет для кожної суми
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Нульова сума може бути досягнута без монет

    # Поповнення масиву dp
    for i in range(1, amount + 1):
        for coin in coins:
            if i - coin >= 0:
                dp[i] = min(dp[i], dp[i - coin] + 1)

    # Повернення кількості монет для заданої суми, якщо вона може бути досягнута
    if dp[amount] == float('inf'):
        return None

    # Визначення які монети і скільки кожної з них було використано
    result = {}
    while amount > 0:
        for coin in coins:
            if amount - coin >= 0 and dp[amount] == dp[amount - coin] + 1:
                result[coin] = result.get(coin, 0) + 1
                amount -= coin
                break

    return result

# Приклад використання функції
print(find_min_coins(113))

"""На основі аналізу часової складності та ефективності при великих сумах, алгоритм динамічного програмування вважається найбільш ефективним для задачі знаходження мінімальної кількості монет, необхідних для формування заданої суми. Хоча алгоритм динамічного програмування може мати більшу часову складність порівняно з жадібним алгоритмом, він забезпечує знаходження точно оптимального рішення для будь-якої суми, незалежно від розміру вхідних даних.

Алгоритм динамічного програмування ефективно вирішує проблему за допомогою підходу "знизу-вгору", обчислюючи оптимальні рішення для всіх проміжних сум від 1 до заданої суми. Це дозволяє врахувати всі можливі комбінації монет для кожної проміжної суми, гарантуючи, що кінцеве рішення буде мінімально можливим за кількістю монет.

У випадках, коли великі суми вимагають точного та ефективного рішення, алгоритм динамічного програмування переважає жадібний алгоритм, який може не завжди забезпечувати оптимальний розподіл монет, особливо для складних наборів номіналів. Таким чином, хоча жадібний алгоритм може виявитися швидшим у деяких ситуаціях, динамічне програмування є більш надійним вибором для гарантії оптимального рішення при великих сумах.
"""